# Тестовое задание на вакансию Intern C++ Programmer


## Задание 1


<details>
  <summary>Условие задания</summary>

На языке С/С++, написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути.

Объяснить плюсы и минусы обеих реализаций.

C/C++ example:

bool isEven(int value){return value%2==0;}

</details>

1. Исходный код: [ссылка](https://github.com/Razred/Lesta_Game_test_task/blob/master/src/Task_1/IsEven.cpp)



**Пояснение**

Функция определяющая является ли число четным.
Данная функция подразумевает собой сравнение последнего бита числа с единицей,
так как только у нечетных чисел последний бит может быть равен 1.

**Сравнение**

1. ```cpp
   bool isEven(int value)
   {
      return value % 2 == 0;
   }
   ```

2. ```cpp
   bool IsEven(int value) 
   {
      return (value & 1) == 0;
   }
   ```

Если сравнивать мою функцию с функцией:
isEven(int value){return value%2==0;}
В теории моя функция должна работать быстрее, так как она совершает всего одну унравную операцию,
что в представлении компьютера должно работать быстрее.
Но на деле могу предположить, что компилятор преобразует  две эти функции к одинаковому виду,
и не будет никакой разницы.


## Задание 2

<details>
  <summary>Условие задания</summary>

На языке С++, написать минимум по 2 класса реализовывающих циклический буфер.

Объяснить плюсы и минусы каждой реализации.

</details>

Я реализовал два варианта циклического буфера, одни построен на статическом массиве, а второй с помощью связного списка.

**Сравнение**
Так как обе реализации являются своеобразной очередью, то доступ к элементам происходит за O(1) по времени.

Также присутствуют различия данных вариантов, хоть и не большие. В списковом варианте используется указатель занимающий от 4 до 8 байт в зависимости от системы.

**Реализация**

1. Исходный код: циклический буфер на массиве [ссылка](https://github.com/Razred/Lesta_Game_test_task/blob/master/src/Task_2/https://github.com/Razred/Lesta_Game_test_task/blob/master/src/Task_2/circle_buffer_array.h)
2. Исходный код: циклический буфер на связном списке [ссылка](https://github.com/Razred/Lesta_Game_test_task/blob/master/src/Task_2/circle_buffer_list.h)



## Задание 3

<details>
  <summary>Условие задания</summary>

На языке С/С++, написать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел.

Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным).

Объяснить почему вы считаете, что функция соответствует заданным критериям.

</details>

**Рассуждения**

Выбор алгоритма сортировки, который будет наиболее эффективным по процессорным тикам, зависит от множества факторов, таких как размер массива, распределение данных и архитектура процессора. Однако, могу предположить, что в обычных условиях одним из самых быстрых алгоритмов будет быстрая сортировка.

Я реализовал быструю сортировку для векторе из STL.

**Средняя сложность**
В среднем быстрая сортировка имеет временную сложность O(n log n)

**По памяти** 
Быстрая сортировка не требует дополнительной памяти, кроме небольшого стека рекурсии.
Значит O(1) по памяти

**Вывод**
Быстрая сортировка может быть неэффективна в случае неудачно выбранного опорного элемента. Но это можно избежать используя различные стратегии выбора, такие как медиана трех или случайный выбор.
Кроме того, для очень маленьких массивов может быть более эффективна сортировка вставками.

Код:

1. Исходный код: [ссылка](https://github.com/Razred/Lesta_Game_test_task/blob/master/src/Task_3/Quick_sort.h)
